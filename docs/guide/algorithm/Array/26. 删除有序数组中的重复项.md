# LC 26. 删除有序数组中的重复项



## 问题描述
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度

## 示例
示例 1：
```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
```

示例 2：
```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
```

## Solution

:::: code-group
::: code-group-item JavaScript

```javascript
var removeDuplicates = function(nums) {
    if(nums.length == 0) return 0;
    var j = 0;
    for(var i = 1; i<nums.length; i++) {
        if(nums[i] != nums[j]) nums[++j] = nums[i];
    }
    return ++j;
};
```

执行用时：`68 ms`, 在所有 JavaScript 提交中击败了`90.70%`的用户
内存消耗：43.5 MB, 在所有 JavaScript 提交中击败了45.98%的用户

:::
::: code-group-item Java

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0;
        for (int i = 0; i < nums.length; i++)
            if (i == 0 || nums[i] != nums[i-1]) nums[j++] = nums[i];
        return j;
    }
}
```

执行用时：`0 ms`, 在所有 Java 提交中击败了100.00%的用户
内存消耗：43.1 MB, 在所有 Java 提交中击败了20.61%的用户

:::
::: code-group-item Python

```python
class Solution:
    def removeDuplicates(self, nums):
        '''
        # 双指针36ms
        fast = slow = 1
        while fast < len(nums):
            # 有序数组，所以只用判断前后两项是否相等
            if nums[fast] != nums[fast - 1]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return 0 if not nums else slow
        '''

        for i in range(len(nums) - 1, 0, -1):
            if nums[i] == nums[i - 1]:
                del nums[i]
        return len(nums)
```

:::
::::


::: details 点击查看示例
```java
import java.util.ArrayList;
import java.util.List;

/**
 * 二叉树
 *
 * 前序遍历：根左右
 * 中序遍历：左根右
 * 后序遍历：左右根
 * 层序遍历：从上到下，从左往右
 *
 * [3,9,20,null,null,15,7],
 *
 *     3
 *    / \
 *   9  20
 *     /  \
 *    15   7
 */


/**
 * 前序遍历：根左右
 * 中序遍历：左根右
 * 后序遍历：左右根
 * 层序遍历：从上到下，从左往右
 *
 */

public class TreeNodeTraversal {
    public static void main(String[] args) {
        /*
        TreeNode node3 = new TreeNode(3);
        TreeNode node2 = new TreeNode(2, node3, null);
        TreeNode node1 = new TreeNode(1, null, node2);
         */
        TreeNode node5 = new TreeNode(7, null, null);
        TreeNode node4 = new TreeNode(15, null, null);
        TreeNode node3 = new TreeNode(20, node4, node5);
        TreeNode node2 = new TreeNode(9, null, null);
        TreeNode node1 = new TreeNode(3, node2, node3);

        // 二叉树的遍历
        Solution solution = new Solution();
        // 前序遍历
        System.out.println(solution.preorderTraversal(node1));      // [3, 9, 20, 15, 7]
        // 中序遍历
        System.out.println(solution.inorderTraversal(node1));       // [9, 3, 15, 20, 7]
        // 后序遍历
        System.out.println(solution.postorderTraversal(node1));     // [9, 15, 7, 20, 3]
        // 层序遍历
        System.out.println(solution.levelOrderTraversal(node1));    // [[3], [9, 20], [15, 7]]
    }
}


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

class Solution {
    private List<Integer> list;
    private List<List<Integer>> leaveList = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        list = new ArrayList<>();
        preOrder(root);
        return list;
    }
    public List<Integer> inorderTraversal(TreeNode root) {
        list = new ArrayList<>();
        inOrder(root);
        return list;
    }

    public List<Integer> postorderTraversal(TreeNode root) {
        list = new ArrayList<>();
        postOrder(root);
        return list;
    }

    public List<List<Integer>> levelOrderTraversal(TreeNode root) {
        dns(root, 0);
        return leaveList;
    }

    /**
     * 前序遍历
     */
    private void preOrder(TreeNode root) {
        if (root == null) return;
        list.add(root.val);
        preOrder(root.left);
        preOrder(root.right);
    }

    /**
     * 中序遍历
     */
    public void inOrder(TreeNode root) {
        if(root == null) return;
        inOrder(root.left);
        list.add(root.val);
        inOrder(root.right);
    }

    /**
     * 后序遍历
     */
    public void postOrder(TreeNode root) {
        if(root == null) return;
        postOrder(root.left);
        postOrder(root.right);
        list.add(root.val);
    }
    /**
     * 层序遍历
     */
    public void dns(TreeNode node, int lever){
        if(node == null) return;
        if(leaveList.size() == lever) leaveList.add(new ArrayList<Integer>());
        leaveList.get(lever).add(node.val);
        dns(node.left, lever+1);
        dns(node.right, lever+1);
    }
}
```
:::